% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/treesurgeon.r
\name{dist_m}
\alias{dist_m}
\title{Calculate tree to tree distances in parallel}
\usage{
dist_m(trees, method, slices = 3, normalise = F)
}
\arguments{
\item{trees}{an object of class 'multiPhylo'.}

\item{method}{character specifying the distance metric. Can be "RF", "quartet", "CID", "MSID" or "SPR".}

\item{slices}{numeric. Number of sub matrices to compute}

\item{normalise}{logical. If T, distance metric is normalised.}
}
\value{
A square matrix of tree to tree distances.
}
\description{
Function to calculate tree to tree distances in parallel using the foreach package.
}
\details{
This function uses the foreach package to calculate tree to tree distances in parallel. Foreach allows for parallel computation of matrices, however tree to tree distance matrices are symmetrical, thus simply using foreach to calculate each cell of the matrix would result in 50 percent redundancy. To lower the amount of redundancy, the function splits the square matrix into a user specifed number of rectangular matrices (using the argument 'slices'). These are dealt with in serial, but each bvalue of the rectangular matrices is computed in parallel. For example, if length(trees) == 99, and slices == 3, the function will split the calculation into three submatrices x[1:33, 1:99], x[34:66, 34:99] and x[67:99, 67:99]. This lowers the redundancy from 50 percent to less than 25 percent. In theory, tree distance matrices can be computed without any redundancy, for example using the future.apply package. However, in practice, I have found this to be nowhere near as fast. Whether or not the dist_m() function is faster than computing the distances in serial depends on a number of factors including the number of trees, the number of tips, the complexity of the distance metric and the number of availible cores. In general, this function is recommended for computing distances between > 1000 trees. The ideal number of slices is difficult to determine. A greater number of slices decreases redundancy but increases the number of serial operations. In general, I recommend setting slices to 3. Unfortunately, Windows does not support forking and thus this function will only work for Linux or Mac users.
}
\examples{
## simulate two groups of trees
t1 <- rtree(40)
trees1 <- t1
for(i in 1:199){ 
  trees1 <- c(trees1, rSPR(t1, 1))
}
t2 <- rSPR(t1, 3)
t2 <- multi2di(t2)
trees2 <- t2
for(i in 1:199){ 
  trees2 <- c(trees2, rSPR(t2, 1))
}
trees <- c(trees1, trees2)

## Register parallel backend for Windows with doParallel
cl <- makeCluster(2)
doParallel::registerDoParallel(cl)

## Register parallel backend for Linux or MacOS with doParallel
nc <- parallel::detectCores()
doParallel::registerDoParallel(cores=nc)

## Calculate tree distances
tree_dists <- dist_m(trees, method = "RF", slices = 3, normalise = T)
## Conduct PCA analysis on tree distances
pca_res <- prcomp(tree_dists)
## Check proportion of variances of principal components
sum_res <- summary(pca_res)
# install.packages("ggplot2")
# install.packages("factoextra")
# library("ggplot2")
# library("factoextra")
fviz_eig(pca_res, addlabels=TRUE, hjust = -0.3)
## plot PCA results
ggplot(pca_res$x, aes(PC1, PC2)) + geom_point(alpha = 0.4, size = 2) +  xlab(paste("PC1 = ", sum_res$importance[2,1], sep = "")) + ylab(paste("PC2 = ", sum_res$importance[2,2], sep = "")) + theme_minimal()

}
